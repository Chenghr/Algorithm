"""
    给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
    每段绳子的长度记为 k[0],k[1]...k[m - 1] 。
    请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？
    例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

    答案需要取模 1e9+7（1000000007），如计算初始结果为: 1000000008，请返回 1。
"""

class Solution:
    def cuttingRope(self, n: int) -> int:
        """本题设计到中间的求余操作，已经不适合用dp来做；
            使用数学思路来解；或者贪心思路求解

            贪心思路：
                推论一: 合理的切分方案可以带来更大的乘积。
                推论二: 若切分方案合理，绳子段切分的越多，乘积越大。
                推论三: 为使乘积最大，只有长度为 2 和 3 的绳子不应再切分，且 3 比 2 更优 （用2~6模拟一下即可）。
            
            另外本题涉及到 “大数越界情况下的求余问题” 
            虽然在 python 下不涉及到越界问题，但是在面试中可能会被问；
            具体的: 循环求余，快速幂求余，基于规则:
                xy mod p = (x mod p)(y mod p) mod p
        """
        def remainder(x, a, p):
            # 快速幂求余
            ans = 1
            while a > 0:
                if a % 2 == 1:
                    ans = (ans * x) % p
                    
                x = (x**2) % p
                a //= 2
            
            return ans
        
        if n < 4:
            return n-1

        num3 = n // 3
        if n % 3 == 2:
            ans = remainder(3, num3, 1000000007) * 2 % 1000000007
        elif n % 3 == 1:
            ans = remainder(3, num3-1, 1000000007) * 2 * 2 % 1000000007
        else:
            ans = remainder(3, num3, 1000000007)
        
        return ans